<html>
<head>
<meta content="text/html; charset=ISO-8859-1"
http-equiv="content-type">
<title>The peerunit architecture</title>
</head>
<body>
<table style="text-align: left; width: 802px; height: 868px;" border="0"
cellpadding="2" cellspacing="2">
<tbody>
<tr>
<td style="vertical-align: top;"><big style="font-weight: bold;"><big><big>The
peerunit architectures<br>
</big></big></big>___________________________________________________________________________________________________<br>
<br>
<a href="#Centralized_architecture">Centralized architecture</a><br>
<a href="#Distributed_architecture">Distributed architecture</a><br>
<br>
<br>
___________________________________________________________________________________________________<br>
<br>
<big style="font-weight: bold;"><big><big><a
name="Centralized_architecture"></a>Centralized architecture</big></big></big><br>
<br>
The centralized architecture has two main components, the tester and
the
coordinator. The role of
the tester is to execute test case actions and to control the
volatility of a single peer. The role of the coordinator is to dispatch
the actions of a test case&nbsp; through the testers and to maintain a
list of unavailable peers. <br>
The UML diagram presented in the figure illustrates the
deployment of the architecture: one coordinator controls several
testers
and each tester runs on a different logical node (the same as the peer
it controls).<br>
<br>
<br>
<img style="width: 447px; height: 156px;" alt=""
src="../images/deployment.bmp"><br>
<br>
<br>
The tester provides two interfaces, for action execution and volatility
control:
<ul>
<li>execute(): executes a given action</li>
<li>leave(), fail(), join(): makes a set of peers leave the
system, abnormally quit and join the system.</li>
</ul>
<br>
The coordinator provides three different interfaces, for action
execution, volatility and test case variables:<br>
<ul>
<li>register(), ok(), fail(), error(): action registration
(performed before all tests) and response for action execution, called
by testers once the execution of an action is finished.</li>
<li>set(), get(): accessors for test case variables.</li>
<li>leave(), fail(), join(): makes a set of peers leave the
system, abnormally quit and join the system.</li>
</ul>
___________________________________________________________________________________________________<br>
<br>
<big style="font-weight: bold;"><big><big><a
name="Distributed_architecture"></a>Distributed architecture</big></big></big><br>
<br>
The distributed architecture has a main component, the tester. The role
of the tester is to execute test case actions and&nbsp; control the
volatility of a single peer. Moreover, it coordinates the&nbsp;
dispatch of the test case actions through distributed testers arranged
in a B-Tree manner. The UML diagram presented in the figure below
illustrates the deployment of the framework: each tester runs on a
logical node (the same as the peer it controls). Yet, a node may have
several testers depending on the order of the tree.<br>
<br>
<img style="width: 298px; height: 179px;" alt=""
src="../images/deployment2.bmp"><br>
<br>
The tester provides four interfaces that can be used whenever writing
test cases. They are for action execution management, volatility
control and test case variables:<br>
<br>
<ul>
<li>register(), execute(), ok(), fail(), error(): performs
action registration (before all tests), action execution and responses
to execution.</li>
<li>leave(), fail(), join(): makes a set of peers leave the
system, abnormally quit or join the system.</li>
<li>set(key, variable), get(key): provides accessors for test
case variables.</li>
</ul>
<br>
<a href="../index.html">home</a> <br>
_______________________________________________________________________________________________</td>
</tr>
</tbody>
</table>
<br>
<br>
<br>
</body>
</html>


