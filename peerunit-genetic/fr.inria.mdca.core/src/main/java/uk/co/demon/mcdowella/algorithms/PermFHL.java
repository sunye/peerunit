package uk.co.demon.mcdowella.algorithms;

import java.util.LinkedList;

/** 
 * <p>
 * This class implements my memory of an algorithm that I believe is
 * written up in a paper by Merrick Furst, John Hopcroft, and Eugene
 * Luks, entitled "Polynomial-Time Algorithms for Permutation Groups,"
 * which was presented at the 21st Annual Symposium on Foundations of
 * Computer Science, October 1980. There are more efficient algorithms around,
 * for instance in the packages GAP and MAGMA,
 * but they use group theory that I don't understand (yet!). This algorithm has been
 * used, for instance, to work out the size of groups connected with the
 * Rubik's cube. 
 * </p>
 * <p>
 * See also 'Fundamental Algorithms for Permutation Groups', by G. Butler,
 * Number 559 in Springer-Verlag's Lecture notes in Computer Science series.
 * We start off with an array of Permutations and construct an object
 * that can be used to see if other Permutations are in the subgroup generated
 * by those permutations, and work out the size of that subgroup. It could in
 * theory be used to produce one way of generating any presented subgroup
 * element,
 * but the number of operations in this path tends to grow exponentially. This
 * code tests out ideas for trying to retard that growth. A very few experiments
 * suggest no enormous improvement.
 * Cost is about n^6 worst case, where n is the number of objects being permuted.
 * There is a table of at most about n^2 entries, and we end up multiplying and
 * checking all pairs of entries in the table.
 * Each check can take up to n permutation multiplications, which cost n each.
 * </p>
 */
 public class PermFHL
 {
    /** Length of permutations involved */
    private int permLen;
    /** table[i*permLen + j] is null or holds the inverse of a permutation
     *  that leaves 0..i-1 untouched and maps i to j. So if we have a
     *  permutation p that leaves 0..i-1 untouched and maps i to j then
     *  q = table[i*permLen + j]*p leaves 0..i untouched, and 
     *  p = table[i*permLen + j]^-1*q. This table allows us to successively
     *  decompose p. p is in the subgroup generated by the permutations iff
     *  we can decompose it to the identity.
     */
    private Permutation table[];
    /** tableOps[] holds the number of operations, starting from the generators
     * presented, needed to generate inverse of the sample in the table.
     * Because we use a cost of 0 to distinguish original generators,
     * this must be some type that can never overflow to zero.
     */
    private double tableOps[];
    /** Decompose a permutation as far as possible, and return the number
     * of operations needed to produce the change, not counting inverses
     * (this means that if you decompose all the way the number is the number
     * of operations needed to produce the permutation using only the original
     * generating elements).
     * @param p the permutation to be decomposed. This ends up as the result
     * of the decomposition: the identity if successful.
     */
    public double decompose(Permutation p)
    {
        if (p.getN() != permLen)
            throw new IllegalArgumentException("Size mismatch");
        int firstOut = 0;
        double ops = 0.0;
        for(;;)
        {
            int out = p.changedFrom(firstOut);
            if (out == permLen)
                return ops;
            int changedTo = p.apply(out);
            int index = out * permLen + changedTo;
            Permutation changer = table[index];
            if (changer == null) // can go no further
                 return ops;
            ops += tableOps[index] + 1;
            p.preMultiply(table[index]);
            firstOut = out + 1;
        }
    }
    /** This interface has to save and return Permutations. It is pluggable so
     *  we can return different Permutations, in the hope of cutting down
     *  the number of operations required for decomposition. In practice, none of
     *  the three options I have does surpassingly well, though I'd vote against
     *  LIFO order (which was just in there to try and show a difference).
     */
    public interface SavePerms
    {
        /** save a permutation and its cost for later
         * @param p the Permutation to save
         * @param ops the cost of that permuation (number of operations required
         * to generate it using only the original generators)
         */
        void save(Permutation p, double ops);
        /** return the top Permutation and its cost, removing it from the
         * saved collection.
         * @param ops[0] should be set to the cost on exit. The cost must be preserved,
         * because we use cost 0 to distinguish original generators
         * @return a Permutation or null if none left and its operation count
         */
        Permutation remove(double[] ops);
    }
    /** This class uses a heap so that it always returns a cheapest
     *  cost Permutation
     */
    public static class HeapSavePerms implements SavePerms
    {
        /** number of valid entries */
        private int valid;
        /** heap of costs: costs[i] <= costs[2i + 1], costs[2i + 2] */
        private double[] costs;
        /** permutation for each associated cost */
        Permutation[] perms;
        public HeapSavePerms()
        {
            valid = 0;
            perms = new Permutation[10];
            costs = new double[perms.length];
        }
        /** was mostly for debugging a performance bug */
        private static int count = 0;
        /** Heap-based save. Note that the first batch of permutations
         *  added will be the generators, all of which have cost 0. This
         *  code will save these first equal-cost permutations without
         *  having to move the heap around at all, because equality
         *  comparisons satisfy the heap inequality
         */
        public void save(Permutation p, double ops)
        {
            // System.err.println("Save " + count++);
            if (valid >= perms.length)
            {
                int len = valid * 2 + 1;
                Permutation[] pt = new Permutation[len];
                System.arraycopy(perms, 0, pt, 0, valid);
                perms = pt;
                double[] ct = new double[perms.length];
                System.arraycopy(ct, 0, costs, 0, valid);
                costs = ct;            
            }
            perms[valid] = p;
            costs[valid] = ops;
            int pos = valid;
            valid++;
            while(pos > 0)
            {
                int x = (valid - 1) >> 1;
                if (costs[x] <= costs[pos])
                    break;
                double ct = costs[pos];
                costs[pos] = costs[x];
                costs[x] = ct;
                Permutation pt = perms[pos];
                perms[pos] = perms[x];
                perms[x] = pt;
                pos = x;
            }
        }
        /** Return a permutation at the top of the heap with its cost and
         *  preserve the heap invariant.
         *  @param ops[0] gets set to the cost
         *  @return a permutation with smallest cost
         */
        public Permutation remove(double[] ops)
        {
            if (valid == 0)
                return null;
            if (valid < 0)
                throw new IllegalStateException("Internal heap error");
            Permutation result = perms[0]; // top of heap: lowest cost
            ops[0] = costs[0];
            valid--;
            perms[0] = perms[valid];
            costs[0] = costs[valid];
            // Now swapped up permutation and cost to fill values returned
            // but have to patch up heap invariant: element has cost <=
            // either of its children
            for (int pos = 0;;)
            {
                int x = 2 * pos + 1;
                if (x >= valid)
                    break;
                int y = x + 1;
                if (y < valid && costs[y] < costs[x])
                {
                    x = y;
                }
                if (costs[x] >= costs[pos])
                    break;
                double ct = costs[pos];
                costs[pos] = costs[x];
                costs[x] = ct;
                Permutation pt = perms[pos];
                perms[pos] = perms[x];
                perms[x] = pt;
                pos = x;
            }
            return result;
        }
    }
    /** Utility class: keeps a permutation together with its cost */
    private static class PermInfo
    {
        private Permutation p;
        private double cost;
        PermInfo(Permutation p, double cost)
        {
            this.p = p;
            this.cost = cost;
        }
        Permutation getP(double[] ops)
        {
            ops[0] = cost;
            return p;
        }
    }
    /** This class stores permutations in FIFO order
     */
    public static class FIFOSavePerms implements SavePerms
    {
        private LinkedList li = new LinkedList();
        public void save(Permutation p, double ops)
        {
            li.addFirst(new PermInfo(p, ops));
        }
        /** return the permutation most recently saved, together with its cost
         * @param ops ops[0] is set to the cost of the Permutation returned
         * @return the most recently saved Permutation
         */
        public Permutation remove(double[] ops)
        {
            if(li.size() == 0)
                return null;
            PermInfo pi = (PermInfo)li.remove(0);
            return pi.getP(ops); 
        }
    }
    /** This class stores permutations in LIFO order.
     */
    public static class LIFOSavePerms implements SavePerms
    {
        private LinkedList li = new LinkedList();
        public void save(Permutation p, double ops)
        {
            li.addLast(new PermInfo(p, ops));
        }
        /** return the permutation least recently saved, together with its cost
         * @param ops ops[0] is set to the cost of the Permutation returned
         * @return the least recently saved Permutation
         */
        public Permutation remove(double[] ops)
        {
            if(li.size() == 0)
                return null;
            PermInfo pi = (PermInfo)li.remove(0);
            return pi.getP(ops); 
        }
    }
    /** This constructor is the main entry point to the algorithm of
     *  Furst, Hopcroft, and Luks, because dealing with all the generators
     *  at once gives us the best chance to cut down on the number of
     *  operations by giving SavePerms maximum choice.
     *  @param generators The generators of the subgroup
     *  @param sp a SavePerms used to save and restore permutations and their
     *  costs. The scheduling of permutations in this is a sort of strategy
     *  plug-in. It should be empty on entry. It will be entry on exit.
     */
    public PermFHL(Permutation[] generators, SavePerms sp)
    {
        if (generators.length <= 0)
            throw new IllegalArgumentException(
                "must be at least one generator");
        permLen = generators[0].getN();
        for (int i = 1; i < generators.length; i++)
            if (permLen != generators[i].getN())
                throw new IllegalArgumentException(
                    "length mismatch in generators");
        // all entries initially null (over half are always null!)
        table = new Permutation[permLen * permLen];
        tableOps = new double[permLen * permLen];
        // set up our store of permutations to work on
        for (int i = 0; i < generators.length; i++)
        {
            sp.save(new Permutation(generators[i]), 0.0);
        }
        addPerms(sp);
    }

    /** Work through all the Permutations saved in sp.
     *  It is clear from the if(ops[0] == 0.0) block that elements in the table
     *  are capable of reconstituting the original permutation. It is also
     *  true that every element in the table that can be filled in is. Each
     *  table element is the inverse of a product of original elements. Let
     *  T be a table element that could be filled in by a product but is
     *  not. In fact, let it be the empty element with the shortest product
     *  representation. Then T = R^-1 * S^-1, where R is a table element,
     *  and S^-1 is a product of table element inverses. R preserves
     *  0..i-1 and maps i to j &gt; i. S preserves 0..k.
     *  If k &gt;= i then T preserves 0..i-1 and maps i to j, so T does
     *  not fill an empty slot - it fits in the same slot as R. If k &lt; i
     *  then T preserves 0..k and maps k+1 to the same place as R^-1 * Q^-1,
     *  where Q fits into whatever slot S should fit into, and Q exists
     *  because T was shortest. But this algorithm
     *  forms R^-1 * Q^-1, because each new table entry is both premultiplied
     *  and postmultiplied by all the existing entrants, so we have a
     *  contradiction.
     */
    private void addPerms(SavePerms sp)
    {

        double[] ops = new double[1];
        // This is me trying to avoid create and immediate drop to garbage
        Permutation temp = null;
        Permutation temp1 = null;

        for(;;)
        { // While there are any permutations which might not be generatable
          // from the table
            Permutation p = sp.remove(ops);
            if (p == null)
                return;
            double decomposeOps = ops[0];
            if (ops[0] == 0.0) 
            {  // This is an original generator, not a decomposed product
                decomposeOps += decompose(p);
                int x = p.changedFrom(0);                
                if (x == permLen)
                { // p now identity, which means that it can be constructed
                  // by multiplying together things already in the table
                    continue;
                }
                // FIRST OF ALL, set up inverse in table. Note that the number
                // of additions to the table is at most n(n-1)/2. The original
                // permutation can be reconstructed by multiplying the
                // inverses of the table elements used to decompose it
                int y = p.apply(x);
                int index = x * permLen + y;
                if (table[index] != null)
                        throw new IllegalStateException("Internal error B");
                table[index] = Permutation.makeInverse(p);
                tableOps[index] = decomposeOps; 
                if (decomposeOps > 0.0)
                {   // can save this for later - it won't get
                    // mistaken as useless because it decomposes with
                    // itself
                    sp.save(p, decomposeOps);
                    continue;
                }
            }
            // Add all products of p with the inverses of existing table
            // entries to the table
            for (int i = 0; i < permLen; i++)
            {
                for (int j = i + 1; j < permLen; j++)
                {
                    int offset = i * permLen + j;
                    Permutation at = table[offset];
                    if (at == null) // Nothing in table
                        continue;
                    // Create table inverse (original) to temp
                    if (temp == null)
                        temp = Permutation.makeInverse(at);
                    else
                        temp.setInverse(at);
                    // Create p * table inverse
                    double cost = decomposeOps + tableOps[offset] + 1.0;
                    if (temp1 == null)
                        temp1 = Permutation.makeProduct(p, temp);
                    else
                        temp1.multiply(p, temp);
                    double dCost = decompose(temp1);
                    // check for decomposition and make table inverse * p                    
                    int xx = temp1.changedFrom(0);
                    if (xx != permLen)
                    {   // Not decomposable - new to us
                        // FIRST OF ALL, set up inverse in table
                        // Since the number of table insertions is bounded,
                        // so is the number of permutations added to store
                        int yy = temp1.apply(xx);
                        int indexx = xx * permLen + yy;
                        if (table[indexx] != null)
                            throw new IllegalStateException("Internal error A");
                        table[indexx] = Permutation.makeInverse(temp1);
                        double costt = cost + dCost;
                        tableOps[indexx] = costt;
                        // each save of a non-generator 
                        // comes after a table addition, so the
                        // number of saves is also bounded
                        sp.save(temp1, costt);
                        temp1 = Permutation.makeProduct(temp, p);
                    }
                    else
                    { 
                        temp1.multiply(temp, p);
                    }
                    // check for decomposition of second product
                    dCost = decompose(temp1);
                    xx = temp1.changedFrom(0);
                    if (xx != permLen)
                    {   // Not decomposable - new to us
                        // FIRST OF ALL, set up inverse in table
                        int yy = temp1.apply(xx);
                        int indexx = xx * permLen + yy;
                        if (table[indexx] != null)
                        {
                            System.err.println("xx " + xx + " yy " + yy);
                            System.err.println("temp1 " + temp1 + " table " +
                                table[indexx]);
                            throw new IllegalStateException("Internal error C");
                        }
                        table[indexx] = Permutation.makeInverse(temp1);
                        double costt = cost + dCost;
                        tableOps[indexx] = costt;
                        sp.save(temp1, cost + dCost);
                        temp1 = null; // don't reuse this
                    }
                }
            }
        }
    }
    /** Return the logarithm of the size of the permutation group represented
     *  in the table. We can work this out because any element of the group
     *  will be decomposed in exactly one way.
     *  @return the logarithm of the size of the permutation group.
     */
    public double logGroupSize()
    {
        double sofar = 0.0;
        for (int i = 0; i < permLen; i++)
        {
            double count = 1.0; // Always include the identity
            for (int j = i + 1; j < permLen; j++)
            {
                if (table[i*permLen + j] != null)
                    count++;
            }
            sofar += Math.log(count);
        }
        return sofar;
    }
    /** Work out the mean and variance of the number of operations required to
     *  decompose a random decomposable permutstion. For this we note that any
     *  decomposable permutation decomposes to a unique choice of permutations from
     *  each row in our matrix, counting the identiy permutation as present in each
     *  row.
     *  @param moments an array for the first and second moments: moments[0] will
     *  be set to the mean number of operations, moments[1] to the variance of the
     *  number of operations.
     */
    public void decompDistrib(double[] moments)
    {
        double mean = 0.0;
        double var = 0.0;
        for (int i = 0; i < permLen; i++)
        {
            double meanHere = 0.0;
            int found = 1; // identity permutation is always an option.
            for (int j = i + 1; j < permLen; j++)
            {
                int index = i*permLen + j;
                if (table[index] == null)
                    continue;
                found++;
                meanHere += tableOps[index] + 1.0;
            }
            meanHere = meanHere/found;
            double varHere = meanHere * meanHere; // identity has 0 cost
            for (int j = i + 1; j < permLen; j++)
            {
                int index = i*permLen + j;
                if (table[index] == null)
                    continue;
                // include cost of multiply at this stage
                double v = tableOps[index] + 1.0 - meanHere;
                varHere += v * v;
            }
            mean += meanHere;
            var += varHere/found;
        }
        moments[0] = mean;
        moments[1] = var;
    }
 }
